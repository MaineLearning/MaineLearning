<?php

define('MYZEBRA_FORM_UPLOAD_RANDOM_NAMES', false);

/**
*       Original Code Zebra_Form by Stefan Gabos (see Documentation text accompanying this package)
*
*       MyZebra_Form, Corrected, Modified and Extended by Nikos M. (nikos.m@icanlocalize.com)
*       (this version requires php 5.2.0 or greater)
**/

/**
 *  MyZebra_Form, a jQuery augmented PHP library for creating and validating HTML forms
 *
 *  It provides an easy and intuitive way of creating template-driven, visually appealing forms, complex client-side and
 *  server-side validations and prevention against cross-site scripting (XSS) and cross-site request forgery (CSRF) attacks
 *  prevention.
 *
 *  For the form validation part you can use the built-in rules (i.e. required fields, emails, minimum/maximum length,
 *  etc) and you can also define custom rules, with extreme ease, depending on your specific needs.
 *
 *  All the basic controls that you would find in a form are available plus a few extra: text, textarea, submit, image,
 *  reset, button, file, password, radio buttons, checkboxes, hidden, captcha, date and time pickers.
 *
 *  One additional note: this class is not a drag and drop utility - it is intended for coders who are comfortable with
 *  PHP, HTML, CSS and JavaScript/jQuery - you will have to build your forms when using this class, but it saves a great
 *  deal of time when it comes to validation and assures that your forms are secure and have a consistent look and feel
 *  throughout your projects!
 *
 *  Requires PHP 4.3.0+ or PHP 5.3+ (compiled with the php_fileinfo extension), and jQuery 1.6.2+
 *
 *  Visit {@link http://stefangabos.ro/php-libraries/zebra-form/} for more information.
 *
 *  For more resources visit {@link http://stefangabos.ro/}
 *
 *  @author     Stefan Gabos <contact@stefangabos.ro>
 *  @version    2.8.5 (last revision: July 23, 2012)
 *  @copyright  (c) 2006 - 2012 Stefan Gabos
 *  @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE
 *  @package    MyZebra_Form
 */

class MyZebra_Form
{

    var $_form_is_valid=false;
    /**
     *  Array containing all the controls added to the form
     *
     *  @var    array
     *
     *  @access private
     */
    var $controls;
    
    var $conditionals;

    /**
     *  Array containing all the error messages generated by the form
     *
     *  @var    array
     *
     *  @access private
     */
    var $errors;
    
    var $messages;

    var $form_errors;
    
    var $form_messages;
    
    var $extra_parameters=null;
    
    var $conditional_settings=null;
    /**
     *  An associative array of items uploaded to the current script via the HTTP POST method.
     *  This property, available only if a file upload has occurred, will have the same values as
     *  {@link http://php.net/manual/en/reserved.variables.files.php $_FILES} plus some extra values:
     *
     *  - <b>path</b>       -   the path where the file was uploaded to
     *  - <b>file_name</b>  -   the name the file was uploaded with
     *  - <b>imageinfo</b>  -   <b>available only if the uploaded file is an image!</b><br>
     *                          an array of attributes specific to the uploaded image as returned by
     *                          {@link http://www.php.net/manual/en/function.getimagesize.php getimagesize()} but
     *                          with meaningful names:<br>
     *                          <b>bits</b><br>
     *                          <b>channels</b><br>
     *                          <b>mime</b><br>
     *                          <b>width</b><br>
     *                          <b>height</b><br>
     *                          <b>type</b> ({@link http://php.net/manual/en/function.exif-imagetype.php possible types})<br>
     *                          <b>html</b><br>
     *
     *  <b>Note that the file name can be different than the original name of the uploaded file!</b>
     *
     *  By design, the script will append
     *  a number to the end of a file's name if at the path where the file is uploaded to there is another file with the
     *  same name (for example, if at the path where a file named "example.txt" is uploaded to, a file with the same name
     *  exists, the file's new name will be "example1.txt").
     *
     *  The file names can also be random-generated. See the {@link MyZebra_Form_Control::set_rule() set_rule()} method and
     *  the <b>upload</b> rule
     *
     *  @var    array
     */
    var $file_upload;

    /**
     *  Indicates the {@link http://en.wikipedia.org/wiki/Filesystem_permissions filesystem} permissions to be set for 
     *  files uploaded through the {@link MyZebra_Form_Control::set_rule() upload} rule.
     *
     *  <code>
     *  $form->file_upload_permissions = '0777';
     *  </code>
     *
     *  The permissions are set using PHP's {@link http://php.net/manual/en/function.chmod.php chmod} function which may
     *  or may not be available or be disabled on your environment. If so, this action will fail silently (no errors or
     *  notices will be shown by the library).
     *
     *  Better to leave this setting as it is.
     *
     *  If you know what you are doing, here is how you can calculate the permission levels:
     *
     *  - 400 Owner Read
     *  - 200 Owner Write
     *  - 100 Owner Execute
     *  - 40 Group Read
     *  - 20 Group Write
     *  - 10 Group Execute
     *  - 4 Global Read
     *  - 2 Global Write
     *  - 1 Global Execute
     *
     *  Default is '0755'
     *
     *  @var    string
     */
    var $file_upload_permissions;

    /**
     *  Array containing the variables to be made available in the template file (added through the {@link assign()}
     *  method)
     *
     *  @var    array
     *
     *  @access private
     */
    var $variables;

    /**
     *  Constructor of the class
     *
     *  Initializes the form.
     *
     *  <code>
     *  $form = new MyZebra_Form('myform');
     *  </code>
     *
     *  @param  string  $name           Name of the form
     *
     *  @param  string  $method         (Optional) Specifies which HTTP method will be used to submit the form data set.
     *
     *                                  Possible (case-insensitive) values are <b>POST</b> an <b>GET</b>
     *
     *                                  Default is <b>POST</b>
     *
     *  @param  string  $action         (Optional) An URI to where to submit the form data set.
     *
     *                                  If left empty, the form will submit to itself.
     *
     *  @param  array   $attributes     (Optional) An array of attributes valid for a <form> tag (i.e. style)
     *
     *                                  Note that the following attributes are automatically set when the control is
     *                                  created and should not be altered manually:
     *
     *                                  <b>action</b>, <b>method</b>, <b>enctype</b>, <b>name</b>
     *
     *  @return void
     */
     
     var $language;
     
     // additional (external) sanitization functions
     /*
        structure
        array(
            'html'=>xss_filter_for_html_output (callable),
            'js'=>xss_filter_for_js_output (callable),
            'attr'=>xss_filter_for_html_attribute_output (callable),
            .. etc..
        )
     */
    private $extra_xss=false;
    
    function getExtraXSS()
    {
        return $this->extra_xss;
    }
    
    function MyZebra_Form($name, $method = 'POST', $action = '', $attributes = '', $extra_xss=false)
    {

        $this->controls = $this->conditionals = $this->variables = $this->errors = $this->messages = $this->form_errors = $this->form_messages = $this->master_labels = array();
        
        $this->extra_parameters=array();
        
        // setup additional xss filters
        if ($extra_xss && isset($extra_xss) && is_array($extra_xss) && !empty($extra_xss))
            $this->extra_xss=$extra_xss;
            
        // default filesysyem permissions for uploaded files
        $this->file_upload_permissions = '0755';

        $this->language=array(
            'csrf_detected' => 'There was a problem with your submission!<br>Possible causes may be that the submission has taken too long, or it represents a duplicate request.<br>Please try again.',
            'days'          => array('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'),
            'months'        => array('January','February','March','April','May','June','July','August','September','October','November','December'),
            'clear_date'    => 'Clear',
            'other'         => 'Other...',
            'select'        => '- select -',
            'spam_detected' => 'Possible spam attempt detected. The posted form data was rejected.',
            'add_new_repeatable_field' =>  'Add Another',
            'remove_repeatable_field'   =>  'Remove',
        );
                                    
        // default values for the form's properties
        $this->form_properties = array(

            'add_timestamp'             => false,
            'timestamp_parameter'       => '_tt',
            'action'                    =>  ($action == '' ? $_SERVER['REQUEST_URI'] : $action),
            'attributes'                =>  $attributes,
            'csrf_cookie_config'        =>  array('path' => '/', 'domain' => '', 'secure' => false, 'httponly' => false),
            'csrf_cookie_name'          =>  'myzebra_csrf_token_' . $name,
            'csrf_storage_method'       =>  false,//'auto',
            'csrf_token'                =>  '',
            'csrf_token_lifetime'       =>  0,
            'csrf_token_name'           =>  'myzebra_csrf_token_' . $name,
            'doctype'                   =>  'xhtml',
            'has_upload'                =>  false,
            'honeypot'                  =>  'myzebra_honeypot_' . $name,
            'identifier'                =>  'name_' . $name,
            'language'                  =>  &$this->language,
            'method'                    =>  strtoupper($method),
            'name'                      =>  $name,
            'other_suffix'              =>  '_other',
            'assets_server_path'        =>  rtrim(dirname(__FILE__), '\\/') . DIRECTORY_SEPARATOR,
            'assets_url'                =>  rtrim(str_replace('\\', '/', 'http' . (isset($_SERVER['HTTPS']) ? 's' : '') . '://' . rtrim($_SERVER['HTTP_HOST'], '\\/') . '/' . substr(rtrim(dirname(__FILE__), '\\/'), strlen($_SERVER['DOCUMENT_ROOT']))), '\\/') . '/',
            'show_all_error_messages'   =>  true,

        );

        // set default client-side validation properties
        $this->client_side_validation(true);

        // get the maximum allowed file size for uploads
        $upload_max_filesize = ini_get('upload_max_filesize');

        // see what it is given in (G, M, K)
        $unit = strtolower(substr($upload_max_filesize, -1));

        // get the numeric value
        $value = substr($upload_max_filesize, 0, -1);

        // convert to bytes
        // notice that there is no break
        switch (strtolower(substr($upload_max_filesize, -1))) {

            case 'g':
                $value*=1024;

            case 'm':
                $value*=1024;

            case 'k':
                $value*=1024;

        }

        // set the form's respective property
        $this->form_properties['max_file_size'] = $value;

        // save the version of PHP as we will use it in some instances to determine how to solve things
        $this->form_properties['php_version'] = str_pad(str_replace('.', '', phpversion()), 5, '0', STR_PAD_RIGHT);

        // include the XSS filter class - the MyZebra_Form_Control class extends this class
        require_once dirname(__FILE__) . '/includes/XSSClean.php';

        // include the Control.php file which contains the MyZebra_Form_Control class which is
        // extended by all of the classes
        require_once dirname(__FILE__) . '/includes/Control.php';

        // load the default language file
        //$this->language('english');

    }

    /**
     *  Adds a control to the form.
     *
     *  <code>
     *  //  create a new form
     *  $form = new MyZebra_Form('my_form');
     *
     *  // add a text control to the form
     *  // the "&" symbol is there so that $obj will be a reference to the object in PHP 4
     *  // for PHP 5+ there is no need for it
     *  $obj = &$form->add('text', 'my_text');
     *
     *  // make the text field required
     *  $obj->set_rule(
     *       'required' => array(
     *          'error',            // variable to add the error message to
     *          'Field is required' // error message if value doesn't validate
     *       )
     *  );
     *
     *  // don't forget to always call this method before rendering the form
     *  if ($form->validate()) {
     *      // put code here
     *  }
     *
     *  //  output the form using an automatically generated template
     *  $form->render();
     *  </code>
     *
     *  @param  string  $type   Type of the control to add.
     *
     *                          Controls that can be added to a form:
     *
     *                          -   {@link MyZebra_Form_Button buttons}
     *                          -   {@link MyZebra_Form_Captcha CAPTCHAs}
     *                          -   {@link MyZebra_Form_Checkbox checkboxes}
     *                          -   {@link MyZebra_Form_Date date pickers}
     *                          -   {@link MyZebra_Form_File file upload controls}
     *                          -   {@link MyZebra_Form_Hidden hidden controls}
     *                          -   {@link MyZebra_Form_Image image button controls}
     *                          -   {@link MyZebra_Form_Label labels}
     *                          -   {@link MyZebra_Form_Note notes}
     *                          -   {@link MyZebra_Form_Password password controls}
     *                          -   {@link MyZebra_Form_Radio radio buttons}
     *                          -   {@link MyZebra_Form_Reset reset buttons}
     *                          -   {@link MyZebra_Form_Select selects}
     *                          -   {@link MyZebra_Form_Submit submit buttons}
     *                          -   {@link MyZebra_Form_Text text box controls}
     *                          -   {@link MyZebra_Form_Textarea textareas}
     *                          -   {@link MyZebra_Form_Time time pickers}
     *
     *  @param  mixed   $arguments  A list of arguments as required by the control that is added.
     *
     *  @return reference           Returns a reference to the newly created object
     */
    function &add_repeatable($type)
    {

        $arguments=func_get_args();
        $obj=call_user_func_array(array($this,"_add"),$arguments);
        
        // get some attributes for the newly created control
        $attributes = $obj->get_attributes(array('id', 'name'));

        // include the file containing the PHP class, if not already included
        require_once dirname(__FILE__) . '/includes/' . 'RepeatableControl' . '.php';
        $repobj=new MyZebra_Form_RepeatableControl($obj);
        // make available the form's properties in the newly created object
        $repobj->form_properties = & $this->form_properties;
        $repobj->form = & $this;
        
        // multiple forms on same page need different control ids
        $repobj->set_attributes(array('id'=>$this->form_properties['name'].'_'.$attributes['id']),true);
        // get some attributes for the newly created control
        $attributes = $repobj->get_attributes(array('id', 'name'));
        $this->controls[$attributes['id']]=&$repobj;
        
        return $repobj;

    }
    
    function &add_conditional_group($id)
    {

        
        // include the file containing the PHP class, if not already included
        require_once dirname(__FILE__) . '/includes/' . 'Container' . '.php';
        require_once dirname(__FILE__) . '/includes/' . 'Conditionalgroup' . '.php';
        
        $id=$this->form_properties['name'].'_'.$id;
        $obj=new MyZebra_Form_Conditionalgroup($id);
        // make available the form's properties in the newly created object
        $obj->form_properties = & $this->form_properties;
        $obj->form = & $this;
        
        // multiple forms on same page need different control ids
        // get some attributes for the newly created control
        $this->controls[$id] = &$obj;
        $this->conditionals[$id] = &$obj;
        
        return $obj;
    }
    
    function &add($type)
    {
        $arguments=func_get_args();
        $obj=call_user_func_array(array($this,"_add"),$arguments);
        // put the reference to the newly created object in the 'controls' array
        // id
        // get some attributes for the newly created control
        $attributes = $obj->get_attributes(array('id', 'name'));
        if ($type!='radios' && $type!='checkboxes')
        {
            // multiple forms on same page need different control ids
            $obj->set_attributes(array('id'=>$this->form_properties['name'].'_'.$attributes['id']),true);
            $attributes = $obj->get_attributes(array('id', 'name'));
        }
        $this->controls[$attributes['id']] = &$obj;
        return $obj;
    }
    
    function &_add($type)
    {

        // if shortcut for multiple radio buttons or checkboxes
        if ($type == 'radios' || $type == 'checkboxes') {

            // if there are less than 3 arguments
            if (func_num_args() < 3)

                // trigger a warning
                _myzebra_form_show_error('For <strong>' . $type . '</strong>, the <strong>add()</strong> method requires at least 3 arguments', E_USER_WARNING);

            // if third argument is not an array
            elseif (!is_array(func_get_arg(2)))

                // trigger a warning
                _myzebra_form_show_error('For <strong>' . $type . '</strong>, the <strong>add()</strong> method requires the 3rd argument to be an array', E_USER_WARNING);

            // if everything is ok
            else {
                 
                // controls' name
                $name = func_get_arg(1);

                // the values and labels
                $values = func_get_arg(2);

                // a 4th argument (the default option) was passed to the method
                $actual_values=array();
                $default=array();
                if (func_num_args() >= 4) {

                    // save the default value
                    $atts = func_get_arg(3);
                    $default=isset($atts['default'])?$atts['default']:$default;
                    $actual_values=isset($atts['actual_values'])?$atts['actual_values']:$actual_values;
                    // if default value is not given as an array
                    // (makes sense for checkboxes when there may be multiple preselected values)
                    // make it an array
                    if (!is_array($default)) $default = array($default);

                }
                
                $counter = 0;
                $objs=array();
                $objs2=array();
                
                // iterate through values and their respective labels
                foreach ($values as $value => $caption) {

                    // create control
                    $obj = & $this->_add(($type == 'radios' ? 'radio' : 'checkbox'), $name, $value, (isset($default) && in_array($value, $default) ? array('checked' => 'checked') : ''));
                    $attributes = $obj->get_attributes(array('id', 'name'));
                    $obj->set_attributes(array('id'=>$this->form_properties['name'].'_'.$attributes['id'],'actual_value'=>isset($actual_values[$value])?$actual_values[$value]:$value),true);
                    $__atts=$obj->get_attributes(array('id','name'));
                    $objs[]=&$obj;
                    
                    // if this is the first control in the array
                    // we will later need to return a reference to it
                    if ($counter++ == 0) $pointer = &$obj;

                    // sanitize controls' name (remove square brackets)
                    $sanitize_name = preg_replace('/\[.*\]$/', '', $name);

                    // add the label for the control
                    $obj2 = & $this->_add('label', 'label_' . $sanitize_name . '_' . $value, $__atts['id']/*$sanitize_name . '_' . $value*/, $caption);
                    $attributes = $obj2->get_attributes(array('id', 'name'));
                    $obj2->set_attributes(array('id'=>$this->form_properties['name'].'_'.$attributes['id']));
                    $objs2[]=&$obj2;
                    
                }
                if ($type=='checkboxes')
                {
                    // include the file containing the PHP class, if not already included
                    require_once dirname(__FILE__) . '/includes/' . 'Checkboxes' . '.php';
                    $contobj=new MyZebra_Form_Checkboxes($this->form_properties['name'].'_'.str_replace(array('[',']'),array('',''),$name).'-checkboxes', $objs,$objs2);
                }
                else
                {
                    // include the file containing the PHP class, if not already included
                    require_once dirname(__FILE__) . '/includes/' . 'Radios' . '.php';
                    $contobj=new MyZebra_Form_Radios($this->form_properties['name'].'_'.str_replace(array('[',']'),array('',''),$name).'-radios', $objs,$objs2);
                }
                // make available the form's properties in the newly created object
                $contobj->form_properties = & $this->form_properties;
                $contobj->form = & $this;


                // if the array of values was not empty
                // return reference to the first control
                //if (isset($pointer)) return $pointer;
                //if (isset($pointer)) return $objs;
                if (isset($pointer)) return $contobj;

            }

        // for all other controls
        } else {

            $file_name = ucfirst(strtolower($type));

            // the classes have the "MyZebra_Form_" prefix
            $class_name = 'MyZebra_Form_' . ucfirst(strtolower($type));

            // include the file containing the PHP class, if not already included
            require_once dirname(__FILE__) . '/includes/' . $file_name . '.php';

            // if included file contains such a class
            if (class_exists($class_name)) {

                // if PHP version is lower than 5
                if (substr(phpversion(), 0, 1) < 5) {

                    // convert arguments passed to the add() method to a string ready to be parsed by eval()
                    // notice that first argument is ignored as it refers to the type of the control to add
                    // and we don't have to pass that to the class
                    $arguments = '';

                    // iterates through the arguments, ignoring the very first one
                    for ($i = 1; $i < func_num_args(); $i++)

                        // and creates the argument list
                        $arguments .= ($arguments != '' ? ',' : '') . var_export(func_get_arg($i), true);

                    // use this method to create the new object with the given arguments
                    eval("\$obj = & new \$class_name(" . $arguments . ");");

                // if PHP version is at least 5
                } else {

                    // prepare arguments passed to the add() method
                    // notice that first argument is ignored as it refers to the type of the control to add
                    // and we don't have to pass that to the class
                    $arguments = array_slice(func_get_args(), 1);

                    // use this method to instantiate the object with dynamic arguments
                    $obj = call_user_func_array(array(new ReflectionClass($class_name), 'newInstance'), $arguments);

                }

                // make available the form's properties in the newly created object
                $obj->form_properties = & $this->form_properties;
                $obj->form = & $this;

                // get some attributes for the newly created control
                $attributes = $obj->get_attributes(array('id', 'name'));

                // perform some extra tasks for different types of controls
                switch ($class_name) {

                    // if the newly created control is a file upload control
                    case 'MyZebra_Form_File':

                        // set a flag to be used at rendering
                        $this->form_properties['has_upload'] = true;

                        break;

                    // if the newly created control is a radio button or a checkbox
                    case 'MyZebra_Form_Radio':
                    case 'MyZebra_Form_Checkbox':

                        // radio buttons and checkboxes might have a "master label", a label that is tied to the radio buttons' or
                        // checkboxes' name rather than individual controls' IDs. (as grouped radio buttons and checkboxes share
                        // the same name but have different values)
                        // we use this so that, if the controls have the "required" rule set, the asterisk is attached to the master
                        // label rather than to one of the actual controls

                        // therefore, we generate a "lookup" array of "master" labels for each group of radio buttons or
                        // checkboxes. this does not means that there will be an actual master label - we use this lookup
                        // array to easily determine if a master label exists when rendering the form

                        // sanitize the control's name
                        $attributes['name'] = preg_replace('/\[.*\]$/', '', $attributes['name']);

                        // if there isn't a master label for the group the current control is part of
                        if (!isset($this->master_labels[$attributes['name']]))

                            // create the entry
                            // the "control" index will hold the actual label's name if a "master" label is added to the form
                            $this->master_labels[$attributes['name']] = array('control' => false);

                        break;

                }

                if ($type=='file')
                    $obj->add_text_field();
                    
                // return the identifier to the newly created object
                //$ret=array(&$obj);
                return $obj;

            }

        }

    }

    /**
     *  Appends a message to an already existing {@link MyZebra_Form_Control::set_rule() error block}
     *
     *  <code>
     *  //  create a new form
     *  $form = new MyZebra_Form('my_form');
     *
     *  // add a text control to the form
     *  // the "&" symbol is there so that $obj will be a reference to the object in PHP 4
     *  // for PHP 5+ there is no need for it
     *  $obj = &$form->add('text', 'my_text');
     *
     *  // make the text field required
     *  $obj->set_rule(
     *       'required' => array(
     *          'error',            // variable to add the error message to
     *          'Field is required' // error message if value doesn't validate
     *       )
     *  );
     *
     *  // don't forget to always call this method before rendering the form
     *  if ($form->validate()) {
     *
     *      // for the purpose of this example, we will do a custom validation
     *      // after calling the "validate" method.
     *      // for custom validations, using the "custom" rule is recommended instead
     *
     *      // check if value's is between 1 and 10
     *      if ((int)$_POST['my_text']) < 1 || (int)$_POST['my_text']) > 10) {
     *
     *          $form->add_error('error', 'Value must be an integer between 1 and 10!');
     *
     *      } else {
     *
     *          // put code here that is to be executed when the form values are ok
     *
     *      }
     *
     *  }
     *
     *  //  output the form using an automatically generated template
     *  $form->render();
     *  </code>
     *
     *  @param  string  $error_block    The name of the error block to append the error message to (also the name
     *                                  of the PHP variable that will be available in the template file).
     *
     *  @param  string  $error_message  The error message to append to the error block.
     *
     *  @return void
     */
    function add_error($error_block, $error_message)
    {

        // if the error block was not yet created, create the error block
        if (!isset($this->errors[$error_block])) $this->errors[$error_block] = array();

        // if the same exact message doesn't already exists
        if (!in_array(trim($error_message), $this->errors[$error_block]))

            // append the error message to the error block
            $this->errors[$error_block][] = trim($error_message);

    }

    function add_message($msg_block, $message)
    {

        // if the error block was not yet created, create the error block
        if (!isset($this->messages[$msg_block])) $this->messages[$msg_block] = array();

        // if the same exact message doesn't already exists
        if (!in_array(trim($message), $this->messages[$msg_block]))

            // append the error message to the error block
            $this->messages[$msg_block][] = trim($message);

    }
    
    function add_form_error($error_block, $error_message)
    {

        // if the error block was not yet created, create the error block
        if (!isset($this->form_errors[$error_block])) $this->form_errors[$error_block] = array();

        // if the same exact message doesn't already exists
        if (!in_array(trim($error_message), $this->form_errors[$error_block]))

            // append the error message to the error block
            $this->form_errors[$error_block][] = trim($error_message);

    }

    function add_form_message($msg_block, $message)
    {

        // if the error block was not yet created, create the error block
        if (!isset($this->form_messages[$msg_block])) $this->form_messages[$msg_block] = array();

        // if the same exact message doesn't already exists
        if (!in_array(trim($message), $this->form_messages[$msg_block]))

            // append the error message to the error block
            $this->form_messages[$msg_block][] = trim($message);

    }
    /**
     *  Set the server path and URL to the "process.php" and "mimes.json" files.
     *
     *  These files are required for CAPTCHAs and uploads.
     *
     *  By default, the location of these files is in the same folder as MyZebra_Form.php and the script will automatically
     *  try to determine both the server path and the URL to these files. However, when the script is run on a virtual
     *  host the script may not correctly determine the paths to these files. In these instances, use this method to
     *  correctly set the server path - needed by the script to correctly include these files, and the URL - needed by
     *  the client-side validation to include these files.
     *
     *  Also, for security reasons, I recommend moving these two files by default to the root of your website (or another
     *  publicly accessible place) and manually set the paths, in order to prevent malicious users from finding out 
     *  information about your directory structure.
     *
     *  @param  string  $server_path    The server path to "process.php" and "mimes.json" files.
     *
     *  @param  string  $url            The URL to "process.php" and "mimes.json" files.
     *
     *  @return void
     */
    function assets_path($server_path, $url)
    {

        // set values
        $this->form_properties['assets_server_path'] = $server_path;
        $this->form_properties['assets_url'] = $url;

    }

    /**
     *  Creates a PHP variable with the given value, available in the template file.
     *
     *  <code>
     *  //  create a new form
     *  $form = new MyZebra_Form('my_form');
     *
     *  // make available the $my_value variable in the template file
     *  $form->assign('my_value', '100');
     *
     *  // don't forget to always call this method before rendering the form
     *  if ($form->validate()) {
     *      // put code here
     *  }
     *
     *  // output the form
     *  // notice that we are using a custom template
     *  // my_template.php file is expected to be found
     *  // and in this file, you may now use the $my_value variable
     *  $form->render('my_template.php');
     *  </code>
     *
     *  @param  string  $variable_name  Name by which the variable will be available in the template file.
     *
     *  @param  mixed   $value          The value to be assigned to the variable.
     *
     *  @return void
     */
    function assign($variable_name, $value)
    {

        // save the variable in an array that we will make available in the template file upon rendering
        $this->variables[$variable_name] = $value;

    }

    /**
     *  Sets properties for the client-side validation.
     *
     *  Client-side validation, when enabled, occurs on the "onsubmit" event of the form.
     *
     *  <code>
     *  //  create a new form
     *  $form = new MyZebra_Form('my_form');
     *
     *  // disable client-side validation
     *  $form->client_side_validation(false);
     *
     *  // enable client-side validation using default properties
     *  $form->client_side_validation(true);
     *
     *  // enable client-side validation using customized properties
     *  $form->client_side_validation(array(
     *      'scroll_to_error'       =>  false,      //  don't scroll the browser window to the error message
     *      'tips_position'         =>  'right',    //  position tips with error messages to the right of the controls
     *      'close_tips'            =>  false,      //  don't show a "close" button on tips with error messages
     *      'validate_on_the_fly'   =>  false,      //  don't validate controls on the fly
     *      'validate_all'          =>  false,      //  show error messages one by one upon trying to submit an invalid form
     *  ));
     *  </code>
     *
     *  To access the JavaScript object and use the public methods provided by it, use $('#formname').data('MyZebra_Form')
     *  where <i>formname</i> is the form's name <b>with any dashes turned into underscores!</b>
     *
     *  <i>Therefore, if a form's name is "my-form", the JavaScript object would be accessed like $('my_form').data('MyZebra_Form').</i>
     *
     *  From JavaScript, these are the methods that can be called on this object:
     *
     *  -   <b>attach_tip(element, message)</b> -   displays an error message attached to the indicated jQuery element;
     *  -   <b>hide_errors()</b>                -   hides all error message tips;
     *  -   <b>show_errors()</b>                -   shows the error message/messages where required, if the form is not validated
     *  -   <b>submit()</b>                     -   submits the form;
     *  -   <b>validate()</b>                   -   checks if the form is valid; returns TRUE or FALSE;
     *
     *  Here's how you can use these methods, in a JavaScript file:
     *
     *  <i>Note that this is just to show how to use each of the methods presented above, and is not the recommended way
     *  of doing custom validations! Refer to the{@link MyZebra_Form_Control::set_rule() set_rule()} method for how to do
     *  custom validations and for a complete example on how to also use AJAX (scroll down to the "custom" rule).</i>
     *
     *  <code>
     *  //  let's submit the form when clicking on a random button
     *
     *  // get a reference to the MyZebra_Form object
     *  var $form = $('#formname').data('MyZebra_Form');
     *
     *  // handle the onclick event on a random button
     *  $('#somebutton').bind('click', function(e) {
     *
     *      // stop default action
     *      e.preventDefault();
     *
     *      // hide all error messages that might still be visible
     *      $form.hide_errors();
     *
     *      // validate the form, and if the form validates
     *      if ($form.validate()) {
     *
     *          // do your own thing here
     *
     *          // maybe do a custom check, and attach an error message to an element
     *          // on the form, if something is not right
     *          if (check_something_here) $form.attach_tip($('#form_element'), 'Error!');
     *
     *          // if everything is ok even after the custom validation, submit the form
     *          else $form.submit();
     *
     *      // if the form is not valid
     *      // show error message/messages where required
     *      } else $form.show_errors();
     *
     *  });
     *  </code>
     *
     *  @param  mixed   $properties     Can have the following values:
     *                                  -   FALSE, disabling the client-side validation;
     *                                  -   TRUE, enabling the client-side validation with the default properties;
     *                                  -   an associative array with customized properties for the client-side validation;
     *
     *                                  In this last case, the available properties are:
     *
     *                                  -   <b>scroll_to_error</b>, boolean, TRUE or FALSE<br>
     *                                      Specifies whether the browser window should be scrolled to the error message
     *                                      or not.<br>
     *                                      Default is <b>TRUE</b>.
     *                                  -   <b>tips_position</b>, string, <i>left</i> or <i>right</i><br>
     *                                      Specifies where the error message tip should be positioned relative to the
     *                                      control.<br>
     *                                      Default is <b>left</b>.
     *                                  -   <b>close_tips</b>, boolean, TRUE or FALSE<br>
     *                                      Specifies whether the tips with error messages should have a "close" button
     *                                      or not<br>
     *                                      Default is <b>TRUE</b>.
     *                                  -   <b>validate_on_the_fly</b>, boolean, TRUE or FALSE<br>
     *                                      Specifies whether values should be validated as soon as the user leaves a
     *                                      field; if set to TRUE and the validation of the control fails, the error
     *                                      message will be shown right away<br>
     *                                      Default is <b>FALSE</b>.
     *                                  -   <b>validate_all</b>, boolean, TRUE or FALSE<br>
     *                                      Specifies whether upon submitting the form, should all error messages be
     *                                      shown at once if there are any errors<br>
     *                                      Default is <b>FALSE</b>.
     *
     *  @return void
     */
    function client_side_validation($properties)
    {

        // default properties of the client-side validation
        $defaults = array(
            'scroll_to_error'       =>  true,
            'tips_position'         =>  'left',
            'close_tips'            =>  true,
            'validate_on_the_fly'   =>  false,
            'validate_all'          =>  false,
        );

        // if client-side validation needs to be disabled
        if ($properties === false)

            $this->form_properties['clientside_validation'] = false;

        // if client-side validation needs to be enabled with default properties
        elseif ($properties === true)

            $this->form_properties['clientside_validation'] = $defaults;

        // if custom settings for client-side validation
        elseif (is_array($properties))

            // if current settings are already stored as an array
            if (is_array($this->form_properties['clientside_validation']))

                // merge the new settings with the old ones
                $this->form_properties['clientside_validation'] = array_merge($this->form_properties['clientside_validation'], $properties);

            // if current settings are not currently an array
            else

                // the new settings will overwrite the previous one
                $this->form_properties['clientside_validation'] = $properties;

    }

    /**
     *  By default, this class generates <b>HTML 4.01 Strict</b> markup.
     *
     *  Use this method if you want the generated HTML markup to validate as <b>XHTML 1.0 Strict</b>.
     *
     *  @param  string  $doctype    (Optional) The DOCTYPE of the generated HTML markup.
     *
     *                              Possible (case-insensitive) values are <b>HTML</b> or <b>XHTML</b>
     *
     *                              Default is HTML.
     *
     *  @return void
     */
    function doctype($doctype = 'html')
    {

        // set the doctype
        $this->form_properties['doctype'] = (strtolower($doctype) == 'xhtml' ? 'xhtml' : 'html');

    }

    /**
     *  Enables protection against {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery Cross-site request
     *  forgery} (CSRF) attacks.
     *
     *  Read more about specifics and a simple implementation on
     *  {@link http://shiflett.org/articles/cross-site-request-forgeries Chris Shiflett's website}.
     *
     *  This method is automatically called by the library - unless you call it yourself *before* the form's {@link validate()}
     *  and {@link render()} methods, so protection against CSRF attacks is enabled by default for all forms and the
     *  script will decide automatically on the method to use for storing the CSRF token: if a session is already started
     *  then the CSRF token will be stored in a session variable or, if a session is not started, the CSRF token will be
     *  stored in a session cookie (cookies that expire when the browser is closed) but, in this case, it offers a lower
     *  level of security.
     *
     *  <i>You are encouraged to start a PHP session before instantiating this class in order to maximize the level of
     *  security of your forms.</i>
     *
     *  The CSRF token is automatically regenerated when the form is submitted regardless if the form validated or not.
     *  A notable exception is that the form doesn't validate but was submitted via AJAX the CSRF token will not be
     *  regenerated - useful if you submit forms by AJAX.
     *
     *  As an added benefit, protection against CSRF attacks prevents "double posts" by design.
     *
     *  <code>
     *  // recommended usage is:
     *
     *  // call session_start() somewhere in your code but before outputting anything to the browser
     *  session_start();
     *
     *  // include the MyZebra_Form
     *  require 'path/to/MyZebra_Form.php';
     *
     *  // instantiate the class
     *  // protection against CSRF attack will be automatically enabled
     *  // but will be less secure if a session is not started (as it will
     *  // rely on cookies)
     *  $form = new MyZebra_Form('my_form');
     *  </code>
     *
     *  @param  integer $csrf_token_lifetime    (Optional) The number of seconds after which the CSRF token is to be
     *                                          considered as expired.
     *
     *                                          If set to "0" the tokens will expire at the end of the session (when the
     *                                          browser closes or session expires).
     *
     *                                          <i>Note that if csrf_storage_method is set to "session" this value cannot
     *                                          be higher than the session's life time as, if idle, the session will time
     *                                          out regardless of this value!</i>
     *
     *                                          Default is 0.
     *
     *  @param  string  $csrf_storage_method    (Optional) Sets whether the CSRF token should be stored in a cookie, in
     *                                          a session variable, or let the script to automatically decide and use
     *                                          sessions if available or a cookie otherwise.
     *
     *                                          Possible values are "auto", "cookie", "session" or boolean FALSE.
     *
     *                                          If value is "auto", the script will decide automatically on what to use:
     *                                          if a session is already started then the CSRF token will be stored in a
     *                                          session variable, or, if a session is not started, the CSRF token will be
     *                                          stored in a cookie with the parameters as specified by the
     *                                          <b>csrf_cookie_config</b> argument (read below).
     *
     *                                          If value is "cookie" the CSRF token will be stored in a cookie with the
     *                                          parameters as specified by the <b>csrf_cookie_config</b> argument (read
     *                                          below).
     *
     *                                          If value is "session" the CSRF token will be stored in a session variable
     *                                          and thus a session must be started before instantiating the library.
     *
     *                                          If value is boolean FALSE (not recommended), protection against CSRF
     *                                          attack will be disabled.
     *
     *                                          The stored value will be compared, upon for submission, with the value
     *                                          stored in the associated hidden field, and if the two values do not match
     *                                          the form will not validate.
     *
     *                                          Default is "auto".
     *
     *  @param  array   $csrf_cookie_config     (Optional) An associative array containing the properties to be used when
     *                                          setting the cookie with the CSRF token (if <b>csrf_storage_method</b> is
     *                                          set to "cookie").
     *
     *                                          The properties that can be set are "path", "domain", "secure" and "httponly".
     *                                          where:
     *
     *                                          -   <b>path</b>     -   the path on the server in which the cookie will
     *                                                                  be available on. If set to "/", the cookie will
     *                                                                  be available within the entire domain. If set to
     *                                                                  '/foo/', the cookie will only be available within
     *                                                                  the /foo/ directory and all subdirectories such
     *                                                                  as /foo/bar/ of domain.<br>
     *                                                                  Default is "/"
     *
     *                                          -   <b>domain</b>   -   The domain that the cookie will be available on.
     *                                                                  To make the cookie available on all subdomains of
     *                                                                  example.com, domain should be set to to
     *                                                                  ".example.com". The . (dot) is not required but
     *                                                                  makes it compatible with more browsers. Setting
     *                                                                  it to "www.example.com" will make the cookie
     *                                                                  available only in the www subdomain.
     *
     *                                          -   <b>secure</b>   -   Indicates whether cookie information should only
     *                                                                  be transmitted over a HTTPS connection.<br>
     *                                                                  Default is FALSE.
     *
     *                                          -   <b>httponly</b> -   When set to TRUE the cookie will be made accessible
     *                                                                  only through the HTTP protocol. This means that
     *                                                                  the cookie won't be accessible by scripting languages,
     *                                                                  such as JavaScript. It has been suggested that
     *                                                                  this setting can effectively help to reduce identity
     *                                                                  theft through XSS attacks (although it is not
     *                                                                  supported by all browsers), but that claim is often
     *                                                                  disputed. Available only in PHP 5.2.0+<br>
     *                                                                  Default is FALSE
     *
     *                                          Not all properties must be set - for the properties that are not set, the
     *                                          default values will be used instead.
     *
     *  @since  2.8.4
     *
     *  @return void
     */
    function csrf($csrf_token_lifetime = 0, $csrf_storage_method = 'auto', $csrf_cookie_config = array('path' => '/', 'domain' => '', 'secure' => false, 'httponly' => false))
    {

        // continue only if protection against CSRF attacks is not disabled and a token was not already generated
        if ($this->form_properties['csrf_storage_method'] !== false && $this->form_properties['csrf_token'] == '') {

            // set the storage method for the CSRF token
            $this->form_properties['csrf_storage_method'] = ($csrf_storage_method === false ? false : strtolower(trim($csrf_storage_method)));

            // if protection against CSRF attacks is not disabled
            if ($this->form_properties['csrf_storage_method'] !== false) {

                // if the script should decide what method to use and a session is already started
                if ($this->form_properties['csrf_storage_method'] == 'auto')

                    // use sessions as storage method
                    if (isset($_SESSION)) $this->form_properties['csrf_storage_method'] = 'session';

                    // if a session is not already started, use cookies as storage method
                    else $this->form_properties['csrf_storage_method'] = 'cookie';

                // set the life time of the CSRF token
                $this->form_properties['csrf_token_lifetime'] = ($csrf_token_lifetime <= 0 ? 0 : $csrf_token_lifetime);

                // set the configuration options for cookies
                $this->form_properties['csrf_cookie_config'] = array_merge($this->form_properties['csrf_cookie_config'], $csrf_cookie_config);

                // generate a new CSRF token (if it is the case)
                $this->_csrf_generate_token();

            }

        }

    }

    /**
     *  Sets the language to be used by some of the form's controls (the date control, the select control, etc.)
     *
     *  The default language is English.
     *
     *  @param  string  $language   The name of the language file to be used, from the "languages" folder.
     *
     *                              Must be specified without extension ("german" for the german language
     *                              not "german.php")!
     *
     *  @var   string
     *
     *  @return void
     */
    function language($language)
    {

        /*
        // include the language file
        require rtrim(dirname(__FILE__), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . 'languages/' . strtolower(trim($language)) . '.php';

        // make the language available in the control
        $this->form_properties['language'] = &$this->language;
        */
        $this->language = $language;
        $this->form_properties['language'] = &$this->language;
    }
    
    function set_extra_parameters($params)
    {
        $this->extra_parameters=array_merge($this->extra_parameters, $params);
    }
    
    // requires php 5.2.0 or greater
    function add_conditional_settings($data, $fields)
    {
        $this->conditional_settings=json_encode(array('fields'=>$fields,'groups'=>$data));
    }
    
    /**
     *  Renders the form.
     *
     *  @param  string  $template       The output of the form can be generated automatically, can be given from a template
     *                                  file or can be generated programmatically by a callback function.
     *
     *                                  For the automatically generated template there are two options:
     *
     *                                  -   when <i>$template</i> is an empty string or is "<i>*vertical</i>", the script
     *                                      will automatically generate an output where the labels are above the controls
     *                                      and controls come one under another (vertical view)
     *
     *                                  -   when <i>$template</i> is "<i>*horizontal</i>", the script will automatically
     *                                      generate an output where the labels are positioned to the left of the controls
     *                                      while the controls come one under another (horizontal view)
     *
     *                                  When templates are user-defined, <i>$template</i> needs to be a string representing
     *                                  the <i>path/to/the/template.php</i>.
     *
     *                                  The template file itself must be a plain PHP file where all the controls
     *                                  added to the form (except for the hidden controls, which are handled automatically)
     *                                  will be available as variables with the names as described in the documentation
     *                                  for each of the controls. Also, error messages will be available as described at
     *                                  {@link MyZebra_Form_Control::set_rule() set_rule()}.
     *
     *                                  A special variable will also be available in the template file - a variable with
     *                                  the name of the form and being an associative array containing all the controls
     *                                  added to the form, as objects.
     *
     *                                  <i>The template file must not contain the <form> and </form> tags, nor any of the
     *                                  <hidden> controls added to the form as these are generated automatically!</i>
     *
     *                                  There is a third method of generating the output and that is programmatically,
     *                                  through a callback function. In this case <i>$template</i> needs to be the name
     *                                  of an existing function.
     *
     *                                  The function will be called with two arguments:
     *
     *                                  -   an associative array with the form's controls' ids and their respective
     *                                      generated HTML, ready for echo-ing (except for the hidden controls which will
     *                                      still be handled automatically);
     *                                  -   an associative array with all the controls added to the form, as objects
     *
     *                                  THE USER FUNCTION MUST RETURN THE GENERATED OUTPUT!
     *
     *  @param  boolean $return         (Optional) If set to TRUE, the output will be returned instead of being printed
     *                                  to the screen.
     *
     *                                  Default is FALSE.
     *
     *  @param  array   $variables      (Optional) An associative array in the form of "variable_name" => "value"
     *                                  representing variable names and their associated values, to be made available
     *                                  in custom template files.
     *
     *                                  This represents a quicker alternative for assigning many variables at once
     *                                  instead of calling the {@link assign()} method for each variable.
     *
     *  @return mixed                   Returns or displays the rendered form.
     */
    function render($template = '', $return = false, $variables = '')
    {

        // if
        if (

            // "process.php" file could not be found
            !file_exists($this->form_properties['assets_server_path'] . 'process.php') ||

            // or "mimes.json" file could not be found
            !file_exists($this->form_properties['assets_server_path'] . 'mimes.json')

        )
        {
            //print_r($this->form_properties['assets_server_path']);
            //print_r('FILE EX '.file_exists($this->form_properties['assets_server_path'] . 'process.php'));
            //print_r('FILE IS '.is_file($this->form_properties['assets_server_path'] . 'process.php'));
            //print_r(dirname(__FILE__));
            // it means the most probably the script is run on a virtual host and that paths need to be set manually so
            // we inform the user about that
            _myzebra_form_show_error('<strong>MyZebra_Form</strong> could not automatically determine the correct path to the "process.php"
            and "mimes.json" files - this may happen if the script is run on a virtual host. To fix this, use the <u>assets_path()</u>
            method and manually set the correct <strong>server path</strong> and <strong>URL</strong> to these files ', E_USER_ERROR);
        }
        
        // if variables is an array
        if (is_array($variables))

            // iterate through the values in the array
            foreach ($variables as $name => $value)

                // make each value available in the template
                $this->assign($name, $value);

        // start generating the output
        $_action=htmlspecialchars($this->form_properties['action']);
        /*if ($this->form_properties['add_timestamp'])
        {
            $_tt=$this->form_properties['timestamp_parameter'].'='.time();
            if (preg_match('!'.$this->form_properties['timestamp_parameter'].'=\d+!', $_action))
                $_action=preg_replace('!'.$this->form_properties['timestamp_parameter'].'=\d+!',$_tt,$_action);
            else
                $_action.=((strpos($_action,'?')===false)?'?'.$_tt:'&'.$_tt);
        }*/
        $output = '<form ' .
            ($this->form_properties['doctype'] == 'html' ? 'name="' . $this->form_properties['name'] . '" ' : '') .
            'id="' . $this->form_properties['name'] . '" ' .
            'action="' . $_action . '" ' .
            'method="' . strtolower($this->form_properties['method']) . '" ';

        // if custom classes are to be set for the form
        if (isset($this->form_properties['attributes']['class']))

            // add the "MyZebra_Form" required class
            $this->form_properties['attributes']['class'] .= ' MyZebra_Form';

        // if no custom classes are set, set the required "MyZebra_Form" class
        else $this->form_properties['attributes']['class'] = 'MyZebra_Form';

        // if any form attributes have been specified
        if (is_array($this->form_properties['attributes']))

            // iterate through the form's attributes
            foreach ($this->form_properties['attributes'] as $attribute => $value)

                // write them
                $output .= ' ' . $attribute . '="' . $value . '"';

        // if the form has file upload controls
        if ($this->form_properties['has_upload'] === true) {

            // add the enctype to the attributes of the <form> tag
            $output .= ' enctype="multipart/form-data"';

            // and add this required hidden field containing the maximum allowed file size
            $this->add('hidden', 'MAX_FILE_SIZE', $this->form_properties['max_file_size']);

            // if client-side validation is not disabled
            if ($this->form_properties['clientside_validation'] !== false)

                // add a new property for the client-side validation
                $this->client_side_validation(array('assets_path' => rawurlencode($this->form_properties['assets_url'])));

        }

        $output .= '>';

        // iterate through the form's controls
        
        $clientside_error_messages='';
        $datepicker_javascript=array();
        $additional='';
        
        foreach ($this->controls as $key => $control) {

            
            // skip containers
            if ($control->isContainer()) continue;
            
            // get some attributes for each control
            //cred_log($key);
            $attributes = $control->get_attributes(array('type', 'for', 'name', 'id', 'multiple', 'other', 'class', 'default_other'));
                
            // sanitize the control's name
            $attributes['name'] = preg_replace('/\[.*\]/', '', $attributes['name']);

            // validate the control's name
            switch ($attributes['name']) {

                // if control has the same name as the form
                case $this->form_properties['name']:
                // if control has the same name as the name of the honeypot's name
                case $this->form_properties['honeypot']:
                // if control has the same name as the name of the field containing the CSRF token
                case $this->form_properties['csrf_token_name']:
                // if control has the name "submit"
                case 'submit':

                    // stop the execution of the script
                    _myzebra_form_show_error('You are not allowed to have a control named "<strong>' .
                        $attributes['name'] . '</strong>" in form "<strong>' .
                        $this->form_properties['name'] . '</strong>"',
                    E_USER_ERROR);

                    break;

            }

            // if control name is not allowed because it looks like the automatically generated controls for <select> controls
            // with the "other" option attached
            if (preg_match('/' . preg_quote($this->form_properties['other_suffix']) . '$/', $attributes['name']) > 0)

                // stop the execution of the script
                _myzebra_form_show_error('You are not allowed to have a control with the name ending in "<strong>' .
                    $this->form_properties['other_suffix'] . '</strong>" in form "<strong>' .
                    $this->form_properties['name'] . '</strong>"', E_USER_ERROR);

            
            $this->controls[$key]->before_render($clientside_error_messages, $datepicker_javascript, $additional);


            // if control is a select control, doesn't have the "multiple" attribute set and has the "other" attribute set
            if (isset($attributes['type']) && $attributes['type'] == 'select' && !isset($attributes['multiple']) && isset($attributes['other'])) {

                // set a special class for the select control so that we know that it has a textbox attached to it

                // add a special class to the control
                $this->controls[$key]->set_attributes(array('class'=>'myzebra-other'), false);

                // add a text control
                $obj = & $this->add('text', $attributes['id'] . $this->form_properties['other_suffix'], $attributes['default_other']);

                // set a special class for the control
                $obj->set_attributes(array('class'=>'myzebra-other'), false);

                // if the select control was not submitted OR it was submitted but the selected option is other than
                // the "other" option
                if (!isset($control->submitted_value) || $control->submitted_value != 'other')

                    // hide the text box
                    $obj->set_attributes(array('class'=>'myzebra-other-invisible'), false);

                // make sure the value in the control propagates
                $obj->get_submitted_value();

                // because we want this control to appear right beneath the select control when the form is auto-generated
                // we need to have it after the select control in the "controls" property

                // as is we just added the control, it means it is at the end of the array
                // we take it off the end of array
                $obj = array_pop($this->controls);

                // find the position of the parent control
                $parent_position = array_search($attributes['name'], array_keys($this->controls));

                // if PHP version is greater that 5.0.2
                if ($this->form_properties['php_version'] > 50200)

                    // use this method to insert the control right after the parent control
                    $this->controls =

                        array_slice($this->controls, 0, $parent_position + 1, true) +

                        array($attributes['id'] . $this->form_properties['other_suffix'] => $obj) +

                        array_slice($this->controls, $parent_position + 1, count($this->controls) - $parent_position, true);

                // for lower PHP versions
                else {

                    // this will hold the modified array
                    $tmp = array();

                    $counter = 0;

                    // iterate through the form's controls
                    foreach ($this->controls as $key1 => $control1) {

                        // the controls that are before the parent control and the parent control
                        if ($counter <= $parent_position)

                            // add them to our temporary array
                            $tmp[$key1] = $control1;

                        // after we added the parent control
                        elseif ($counter == $parent_position + 1) {

                            // insert the new control
                            $tmp[$attributes['id'] . $this->form_properties['other_suffix']] = $obj;

                            // also insert the control that was previously at this position
                            $tmp[$key1] = $control1;

                        // for all controls after the parent control
                        } else

                            // add them to the temporary array
                            $tmp[$key1] = $control1;

                        ++$counter;

                    }

                    // make the controls array a copy of the temporary array
                    $this->controls = $tmp;

                }

            }

            // if control is a label and is a "master" label
            if (isset($attributes['type']) && $attributes['type'] == 'label' && array_key_exists($attributes['for'], $this->master_labels))

                // save the "master" label's name
                $this->master_labels[$attributes['for']]['control'] = $attributes['name'];

        }

        // we add automatically this hidden control to the form , used to know that the form was submitted
        $this->add('hidden', $this->form_properties['identifier'], $this->form_properties['name']);

        // add a "honeypot" - a text field that we'll use to try and prevent spam-bots
        // this field will be hidden from users and we expect only spam-bots to fill it. if this field will not be empty
        // when submitting the form, we'll consider that the form was submitted by a spam-bot
        $this->add('text', $this->form_properties['honeypot'], '', array('autocomplete' => 'off'));

        // enable protection against CSRF attacks using the default values
        // note that this has no effect if this method was already called before
        $this->csrf();

        // if CSRF protection is enabled (is not boolean FALSE)
        if ($this->form_properties['csrf_storage_method'] !== false)

            // add a hidden field to the form, containing the random token
            // (we will later compare the value in this field with the value in the associated session/cookie)
            $this->add('hidden', $this->form_properties['csrf_token_name'], $this->form_properties['csrf_token']);

        // start rendering the form's hidden controls
        $output .= '<div class="myzebra-form-hidden">';

        // iterate through the controls assigned to the form, looking for hidden controls
        // also, use this opportunity to see which labels are attached to "required" controls
        foreach ($this->controls as $key1 => $control1) {

            // skip containers
            if ($control1->isContainer()) continue;

            // get some attributes for each control
            $attributes = $control1->get_attributes(array('type', 'for', 'name', 'label', 'inside'));

            // sanitize the control's name
            $attributes['name'] = preg_replace('/\[.*\]$/', '', $attributes['name']);

            // if control is a "hidden" control
            if ($attributes['type'] == 'hidden' && !$control1->attributes['user_defined']) {

                // append the hidden control to the hidden control's block
                $output .= $control1->toHTML();

                // take the control out of the controls array because we don't have to bother with it anymore
                unset($this->controls[$key1]);

            // if control is a text field and is the control intended for the "honeypot"
            } elseif ($attributes['type'] == 'text' && $attributes['name'] == $this->form_properties['honeypot']) {

                // because http://www.w3.org/WAI/GL/WCAG20/WD-WCAG20-TECHS/html.html#H44 requires it,
                // attach a label to the control
                $output .= '<label for="' . $this->form_properties['honeypot'] .  '" style="display:none">Leave this field blank</label>';

                // append the control to the hidden control's block (it will not be visible)
                $output .= $control1->toHTML();

                // take the control out of the controls array so we don't have to bother with it anymore
                unset($this->controls[$key1]);

            // if
            } elseif (

                // control is a label AND
                $attributes['type'] == 'label' &&

                // has the "for" attribute set
                isset($attributes['for']) &&

                (

                    // represents a label for a group of checkboxes or radio buttons
                    array_key_exists($attributes['for'], $this->master_labels) ||

                    // the label is attached to an existing control
                    array_key_exists($attributes['for'], $this->controls)

                )

            ) {

                // if the label is attached to an existing control
                if (array_key_exists($attributes['for'], $this->controls)) {

                    // get some attributes of the control the label is attached to
                    $ctrl_attributes = $this->controls[$attributes['for']]->get_attributes(array('name', 'id', 'type'));

                    // sanitize the control's name
                    $ctrl_attributes['name'] = preg_replace('/\[.*\]$/', '', $ctrl_attributes['name']);

                    // if
                    if (

                        // the label has the "inside" attribute set
                        isset($attributes['inside']) &&

                        // the label's "inside" attribute is set to TRUE AND
                        $attributes['inside'] === true &&

                        // the type of the control the label is attached to is either text, textarea or password
                        (isset($ctrl_attributes['type']) && (

                            $ctrl_attributes['type'] == 'text' ||

                            $ctrl_attributes['type'] == 'textarea' ||

                            $ctrl_attributes['type'] == 'password'

                        ))

                    ) {

                        // set some extra attributes for the control the label is attached to
                        $this->controls[$attributes['for']]->set_attributes(array(

                            // for textareas we set the "title" attribute while for the text and password
                            // controls we set the "alt" attribute
                            'title' => $attributes['label'],

                        ));

                        // set some extra attributes for the control the label is attached to
                        $this->controls[$attributes['for']]->set_attributes(array(

                            // set a class, used by the JavaScript to set some extra attributes at runtime
                            'class' => 'myzebra-inner-label',

                        ), false);

                    // if the control the label is attached to a radio button or a checkbox
                    } elseif ($ctrl_attributes['type'] == 'radio' || $ctrl_attributes['type'] == 'checkbox')

                        // set a specific class for the label control
                        $control->set_attributes(array('class' => 'myzebra-option'));

                }

                // if the control the label is attached to has the "disabled" attribute set
                if (isset($this->controls[$attributes['for']]->attributes['disabled']))

                    // set a special class for the label
                    $control->set_attributes(array('class' => 'myzebra-disabled'), false);

                // if the control the label is attached to, has the "required" rule set
                if (isset($this->controls[$attributes['for']]->rules['required']))

                    // if
                    if (

                        // a "master" label could exist for the control the label is attached to
                        array_key_exists($ctrl_attributes['name'], $this->master_labels) &&

                        // and a control that could be the "master" label exists
                        isset($this->controls[$this->master_labels[$ctrl_attributes['name']]['control']])

                    ) {

                        // if asterisk is not already attached
                        if (strpos($this->controls[$this->master_labels[$ctrl_attributes['name']]['control']]->attributes['label'], '<span class="myzebra-required">*</span>') === false)

                            // attach the asterisk to the "master" label instead rather than to the current label
                            $this->controls[$this->master_labels[$ctrl_attributes['name']]['control']]->set_attributes(array('label' => $this->controls[$this->master_labels[$ctrl_attributes['name']]['control']]->attributes['label'] . '<span class="myzebra-required">*</span>'));

                    // otherwise
                    } else

                        // attach the asterisk to the current label
                        $this->controls[$key]->set_attributes(array('label' => $attributes['label'] . '<span class="myzebra-required">*</span>'));

            // if
            } elseif (

                // control is a label AND
                $attributes['type'] == 'label' &&

                // has the "for" attribute set
                isset($attributes['for']) &&

                // is neither a "master" label for a group of checkboxes or radio buttons
                !array_key_exists($attributes['for'], $this->master_labels) &&

                // nor is attached to an existing control
                !array_key_exists($attributes['for'], $this->controls) &&

                // we're not on autopilot (if we are, we will remove the "for" attribute later on)
                ($template != '' && $template != '*horizontal' && $template != '*vertical')

            // remove the "for" attribute so that the form will pass the W3C validation
            ) unset($this->controls[$key]->attributes['for']);

        }

        // finish building the hidden controls block
        $output .= '</div>';

        // if output is to be auto-generated
        /*if ($template == '' || $template == '*horizontal' || $template == '*vertical') {

            $error_messages = '';

            // iterate through any existing error blocks
            // and render them at the top of the auto-generated output
            foreach ($this->errors as $errors) $error_messages .= $errors;

            // group controls in master label/control/label/note
            $blocks = array();

            // iterate through the form's controls
            foreach ($this->controls as $key1=>$control1) {

                // get some attributes for the control
                $attributes = $control1->get_attributes(array('type', 'name', 'id', 'for', 'inside'));

                // if control is a label that is to be placed inside another control, we skip it
                if (isset($attributes['inside'])) continue;

                // sanitize control's name
                $attributes['name'] = preg_replace('/\[\]$/', '', $attributes['name']);

                // if the control is a text box that is to be shown when user selects "other" in a select control
                if (preg_match('/(.*)' . preg_quote($this->form_properties['other_suffix']) . '$/', $attributes['name'], $matches) > 0)

                    // save the control the current control is attached to
                    $parent = $matches[1];

                // for other controls
                else {

                    // check the control's type
                    switch ($attributes['type']) {

                        // if control is captcha, label or note
                        case 'captcha':
                        case 'label':
                        case 'note':

                            // save the control the current control is attached to
                            $parent = $attributes['for'];

                            // if
                            if (

                                // parent control exist AND
                                isset($this->controls[$parent]) &&

                                // control is a checkbox or radio button
                                ($this->controls[$parent]->attributes['type'] == 'checkbox' || $this->controls[$parent]->attributes['type'] == 'radio') &&

                                // the parent control's ID is different the parent control's name
                                // (as is the case for radio buttons and checkboxes)
                                $this->controls[$parent]->attributes['id'] != $this->controls[$parent]->attributes['name']

                            )

                                // save the both the "master" parent and, separated by a dot, the actual parent
                                $parent = preg_replace('/\[\]$/', '', $this->controls[$parent]->attributes['name']) . '.' . $parent;

                            // if control is a label and the parent control doesn't exist (the label is most probably a "master" label)
                            elseif ($attributes['type'] == 'label' && !isset($this->controls[$parent]))

                                // remove the "for" attribute so that the form will pass the W3C validation
                                unset($this->controls[$key1]->attributes['for']);

                            break;

                        // for any other controls
                        default:

                            // the parent is the control itself
                            $parent = $attributes['name'];

                    }

                }

                // as some controls (labels for checkboxes) can have multiple parent - the checkbox control and a master
                // label - and multiple parents are separated by a dot, explode by dot
                $parents = explode('.', $parent);

                // iterate through the control's parents
                foreach ($parents as $key => $parent) {

                    // if firs entry
                    // make $array a pointer to the $blocks array
                    if ($key == 0) $array = & $blocks;

                    // if the parent control doesn't have its own key in the array
                    // (it may still be in the array but not as a "parent")
                    if (!isset($array[$parent])) {

                        // initialize the entry
                        $array[$parent] = array();

                        // this works only on PHP 4.2.0 or above
                        // if we already have the entry but not as a key
                        if (($pos = array_search($parent, $array)) !== false) {

                            // insert it in the newly created entry
                            $array[$parent][] = $array[$pos];

                            // and remove it from the old position
                            unset($array[$pos]);

                        }

                    }

                    // make $array a pointer
                    $array = & $array[$parent];

                    // if we're at the last parent
                    if ($key == count($parents) - 1)

                        // if control already exits in the parent's array as a key (remember that $array is a pointer!)
                        if (array_key_exists($attributes['id'], $array))

                            // add the control to the array
                            $array[$attributes['id']][] = $attributes['id'];

                        // if control doesn't exit in the parent's array (remember that $array is a pointer!)
                        else

                            // add the control to the array
                            $array[] = $attributes['id'];

                }

            }

            // if auto-generated output needs to be horizontal
            if ($template == '*horizontal') {

                // the output will be enclosed in a table
                $contents = '<table>';

                // if there are errors to be displayed
                if ($error_messages != '')

                    // show the error messages
                    $contents .= '<tr><td colspan="2">' . $error_messages . '</td></tr>';

                // keep track of odd/even rows
                $counter = 0;

                // total number of rows to be displayed
                $rows = count($blocks);

                // iterate through blocks
                foreach ($blocks as $controls) {

                    ++$counter;

                    // each block is in its own row
                    $contents .= '<tr class="row' . ($counter % 2 == 0 ? ' even' : '') . ($counter == $rows ? ' last' : '') . '">';

                    // the first cell will hold the label (if any)
                    $contents .= '<td valign="top">';

                    // as of PHP 5.3, array_shift required the argument to be a variable and not the result
                    // of a function so we need this intermediary step
                    $labels = array_values($controls);

                    // retrieve the first item in the block
                    $label = array_shift($labels);

                    // item is a label
                    if (!is_array($label) && $this->controls[$label]->attributes['type'] == 'label') {

                        // remove it from the block
                        array_shift($controls);

                        // render it
                        $contents .= $this->controls[$label]->toHTML();

                    }

                    // close the table cell
                    $contents .= '</td>';

                    // the second cell contains the actual controls
                    $contents .= '<td valign="top">';

                    // iterate through the controls to be rendered
                    foreach ($controls as $control) {

                        // if array of controls
                        // (radio buttons/checkboxes and their labels)
                        if (is_array($control)) {

                            // iterate through the array's items
                            foreach ($control as $ctrl)

                                // and display them on the same line
                                $contents .= '<div class="cell">' . $this->controls[$ctrl]->toHTML() . '</div>';

                            // clear floats
                            $contents .= '<div class="clear"></div>';

                        // if not an array of controls
                        } else

                            // if control is required but has the label as a tip inside the control
                            // we need to manually add the asterisk after the control
                            if (array_key_exists('required', $this->controls[$control]->rules) && preg_match('/\binner\-label\b/', $this->controls[$control]->attributes['class'])) {

                                // first, make sure the control is inline so that the asterisk will be placed to the right of the control
                                $this->controls[$control]->set_attributes(array('class' => 'inline'), false);

                                // add the required symbol after the control
                                $contents .= $this->controls[$control]->toHTML() . '<span class="required">*</span>';

                            // else, render the control
                            } else $contents .= $this->controls[$control]->toHTML();

                    }

                    // close the cell
                    $contents .= '</td>';

                    // add a "separator" row
                    $contents .= '</tr>';

                }

                // finish rendering the table
                $contents .= '</table>';

            // if auto-generated output needs to be vertical
            } else {

                $contents = '';

                // if there are errors to be displayed, show the error messages
                if ($error_messages != '') $contents .= $error_messages;

                $counter = 0;

                // total number of rows to be displayed
                $rows = count($blocks);

                // iterate through blocks
                foreach ($blocks as $controls) {

                    // each block is in its own row
                    $contents .= '<div class="row' . (++$counter % 2 == 0 ? ' even' : '') . ($counter == $rows ? ' last' : '') . '">';

                    // iterate through the controls to be rendered
                    foreach ($controls as $control) {

                        // if array of controls
                        // (radio buttons/checkboxes and their labels)
                        if (is_array($control)) {

                            // iterate through the array's items
                            foreach ($control as $ctrl)

                                // and display them on the same line
                                $contents .= '<div class="cell">' . $this->controls[$ctrl]->toHTML() . '</div>';

                            // clear floats
                            $contents .= '<div class="clear"></div>';

                        // if not an array of controls
                        } else

                            // if control is required but has the label as a tip inside the control
                            // we need to manually add the asterisk after the control
                            if (array_key_exists('required', $this->controls[$control]->rules) && preg_match('/\binner\-label\b/', $this->controls[$control]->attributes['class'])) {

                                // first, make sure the control is inline so that the asterisk will be placed to the right of the control
                                $this->controls[$control]->set_attributes(array('class' => 'inline'), false);

                                // add the required symbol after the control
                                $contents .= $this->controls[$control]->toHTML() . '<span class="required">*</span>';

                            // else, render the control
                            } else $contents .= $this->controls[$control]->toHTML();

                    }

                    // finish rendering
                    $contents .= '</div>';

                }

            }

        // if a function with the name given as $template exists
        }*/ /*else*/if (is_array($template) || function_exists($template)) {

           // this variable will contain all the rendered controls
            $controls = array();

            // if there are any error messages
            if (!empty($this->form_errors))
            {

                // iterate through each error block
                foreach ($this->form_errors as $error_block => $error_messages) 
                {

                    $content = '<ul>';

                    // iterate through each message of the error block
                    foreach ($error_messages as $error_message) {

                        // render each message in block
                        $content .= '<li>' . $error_message . '</li>';

                        // if only one error message is to be show
                        // break out from the foreach loop
                        if ($this->form_properties['show_all_error_messages'] === false) break;

                    }
                    $content .= '</ul>';

                    // switch the array entry with it's rendered form
                    $this->form_errors[$error_block] = '<div class="myzebra-form-error"><div class="myzebra-container">' . $content . '<div class="myzebra-close"><a href="javascript:void(0)">close</a></div></div></div>';

                }
            }
            // if there are any error messages
            if (!empty($this->form_messages))
            {
                // iterate through each error block
                foreach ($this->form_messages as $msg_block => $messages) 
                {

                    $content = '<ul>';

                    // iterate through each message of the error block
                    foreach ($messages as $message) {

                        // render each message in block
                        $content .= '<span>' . $message . '</span>';

                    }

                    $content .= '</ul>';
                    // switch the array entry with it's rendered form
                    $this->form_messages[$msg_block] = '<div class="myzebra-form-message"><div class="myzebra-container">' . $content . '<div class="myzebra-close"><a href="javascript:void(0)">close</a></div></div></div>';

                }
            }
            $error_messages = '';
            $messages = '';
             
            // iterate through any existing error blocks
            // and render them at the top of the auto-generated output
            foreach ($this->form_errors as $errors) $error_messages .= $errors;
            unset($this->form_errors);
            // iterate through any existing error blocks
            // and render them at the top of the auto-generated output
            foreach ($this->form_messages as $msgs) $messages .= $msgs;
            unset($this->form_messages);
            
            // iterate through the controls assigned to the form
            foreach ($this->controls as $control) 
            {

                // skip containers
                if ($control->isContainer()) continue;

                // read some attributes of the control
                $attributes = $control->get_attributes(array('name', 'id', 'inside', 'type'));

                // render the control if the control is not a label that is to be displayed inside the control as it's
                // default value
                if (!isset($attributes['inside']))

                    // if control is required but has the label as a tip inside the control
                    // we need to manually add the asterisk after the control
                    if (array_key_exists('required', $control->rules) && isset($control->attributes['class']) && preg_match('/\bmyzebra\-inner\-label\b/', $control->attributes['class'])) 
                    {

                        // first, make sure the control is inline so that the asterisk will be placed to the right of the control
                        $control->set_attributes(array('class' => 'myzebra-inline'), false);

                        // add the required symbol after the control
                        // and add generated HTML code to the $controls array
                        $controls[$attributes['id']] = $control->toHTML() . '<span class="myzebra-required">*</span>';

                    // otherwise, add generated HTML code to the $controls array
                    }
                    // messages container control
                    elseif ($attributes['type']=='messages')
                    {
                        //pass the messages texts
                        $control->set_attributes(array(
                        'errors'=>$error_messages,
                        'messages'=>$messages
                        ));
                        // render it
                        $controls[$attributes['id']] = $control->toHTML();
                    }
                    else $controls[$attributes['id']] = $control->toHTML();
                
            }

            // iterate through the variables assigned to the form
            foreach ($this->variables as $variable_name => $variable_value)
                // make available the assigned variables
                $controls[$variable_name] = $variable_value;

            // let the custom function generate the output
            // we're passing two arguments
            // an associative array with control ids and their respectively generated HTML
            // and an array with all the form's objects
            $contents = /*$error_messages. $messages.*/ call_user_func_array($template, array($controls, &$this->controls));

        // if a template was specified
        } /*else {

            // this variable will contain all the rendered controls
            $controls = array();

            // iterate through the controls assigned to the form
            foreach ($this->controls as $control) {

                // read some attributes of the control
                $attributes = $control->get_attributes(array('id', 'inside'));

                // render the control if the control is not a label that is to be displayed inside the control as it's
                // default value
                if (!isset($attributes['inside']))

                    // if control is required but has the label as a tip inside the control
                    // we need to manually add the asterisk after the control
                    if (array_key_exists('required', $control->rules) && preg_match('/\binner\-label\b/', $control->attributes['class'])) {

                        // first, make sure the control is inline so that the asterisk will be placed to the right of the control
                        $control->set_attributes(array('class' => 'inline'), false);

                        // add the required symbol after the control
                        // and add generated HTML code to the $controls array
                        $controls[$attributes['id']] = $control->toHTML() . '<span class="required">*</span>';

                    // otherwise, add generated HTML code to the $controls array
                    } else $controls[$attributes['id']] = $control->toHTML();

            }

            //start output buffering
            ob_start();

            // make available in the template all the form's objects
            $controls[$this->form_properties['name']] = &$this->controls;

            // make the user-defined variables available in the template file as PHP variables
            extract($this->variables);

            // make the rendered controls available in the template file as PHP variables
            extract($controls);

            // make the error messages available in the template file as PHP variables
            extract($this->errors);

            // include the template file
            include $template;

            // put the parsed content in a variable
            $contents = ob_get_contents();

            // clean buffers
            ob_end_clean();

        }*/

        // finish building the output
        $output = $output . $contents . '</form>';

        // this will hold the properties to be set for the JavaScript object
        $javascript_object_properties = '';

        // if there are properties to be set for the JavaScript object
        if (is_array($this->form_properties['clientside_validation']))

            // iterate through the properties
            foreach ($this->form_properties['clientside_validation'] as $key => $value)

                // save property
                $javascript_object_properties .=
                    ($javascript_object_properties != '' ? ',' : '') . $key . ':' .
                    ($value === true ? 'true' : ($value === false ? 'false' : '\'' . $value . '\''));

        // if client side validation is enabled and any rules are defined
        if (isset($clientside_error_messages))

            // save property
            $javascript_object_properties .= ($javascript_object_properties != '' ? ',' : '') . 'error_messages:{' . $clientside_error_messages . '}';

        // function name for initializing client-side validation
        $function_name = 'cred_form_init_' . md5(strtolower($this->form_properties['name'] . microtime()));

/*       $output .=
            '<script type="text/javascript">function ' . $function_name . '(){if(typeof jQuery=="undefined"||typeof jQuery.fn.MyZebra_Form=="undefined"' .
            (isset($datepicker_javascript) ? '|| jQuery.fn.MyZebra_DatePicker=="undefined"' : '') . '){setTimeout("' . $function_name . '()",100);return}' .
            (isset($datepicker_javascript) ? $datepicker_javascript : '') .
            'jQuery("#' . $this->form_properties['name'] . '").MyZebra_Form(' . ($javascript_object_properties != '' ? '{' . $javascript_object_properties . '}' : '') . ')}' .
            ''.$function_name . '();</script>';*/

        if (isset($datepicker_javascript))
        {
            $datepicker_javascript_output='myzebra_datepicker:{';
            $datepicker_i=0;
            foreach ($datepicker_javascript as $cont=>$dateobj)
            {
                if ($datepicker_i==0)
                    $datepicker_javascript_output .= '"'.$cont.'" : '.$dateobj;
                else
                    $datepicker_javascript_output .= ',"'.$cont.'" : '.$dateobj;
                $datepicker_i++;
            }
            $datepicker_javascript_output.='}';
            $javascript_object_properties .= ($javascript_object_properties != '' ? ',' : '') . $datepicker_javascript_output;
        }
        else
            $datepicker_javascript_output='';
        
        // add conditional settings
        if ($javascript_object_properties != '')
            $javascript_object_properties.=',conditionals:'.((isset($this->conditional_settings))?$this->conditional_settings:'false');
        else
            $javascript_object_properties.='conditionals:'.((isset($this->conditional_settings))?$this->conditional_settings:'false');
        
        $control_js='';
        // get custom control javascript
        foreach ($this->controls as $control)
            $control_js.=$control->getJS();
            
        $js_output='';
        $js_output .=
            "\n".'<script type="text/javascript">/* <![CDATA[ */'."\n".$additional.
'function ' . $function_name . '(){if(typeof (jQuery)=="undefined"||typeof (jQuery.fn.MyZebra_Form)=="undefined"' .
            ((isset($datepicker_javascript) && !empty($datepicker_javascript)) ? '|| typeof(jQuery.fn.MyZebra_DatePicker)=="undefined"' : '') . '){/*setTimeout("' . $function_name . '()",100);*/alert("no script");return;}' .
            'jQuery("#' . $this->form_properties['name'] . '").MyZebra_Form(' . ($javascript_object_properties != '' ? '{' . $javascript_object_properties . '}' : '') . ');'."\n" . $control_js."\n" .'};'."\n" .
            'jQuery(function(){'.$function_name . '();});'."\n".'/* ]]> */</script>'."\n";
        
        // if $return argument was TRUE, return the result
        if ($return) return array($output, $js_output);

        // if $return argument was FALSE, output the content
        else echo $output.$js_output;

    }

    /**
     *  Resets the submitted values for all of the form's controls (also resets the POST/GET/FILES superglobals)
     *
     *  @return void
     */
    function reset()
    {
        // iterate through the form's controls
        foreach ($this->controls as $key=>$control) {
            // reset
            $this->controls[$key]->reset();
        }
    }

    /**
     *  Sets how error messages generated upon server-side validation are displayed in an
     *  {@link MyZebra_Form_Control::set_rule() error block}.
     *
     *  Client-side validation is done on the "onsubmit" event of the form. See {@link client_side_validation()} for
     *  more information on client-side validation.
     *
     *  <code>
     *  //  create a new form
     *  $form = new MyZebra_Form('my_form');
     *
     *  //  display all error messages of error blocks
     *  $form->show_all_error_messages(true);
     *  </code>
     *
     *  @param  boolean $value  Setting this argument to TRUE will display <i>all</i> error messages of an error block,
     *                          while setting it to FALSE will display one error message at a time.
     *
     *                          Default is FALSE.
     *
     *
     *  @return                 void
     */
    function show_all_error_messages($value = false)
    {

        // set the property
        $this->form_properties['show_all_error_messages'] = $value;

    }

    /**
     *  This method performs the server-side validation of all the form's controls, making sure that all the values
     *  comply to the rules set for these controls through the {@link MyZebra_Form_Control::set_rule() set_rule()} method.
     *
     *  Only by calling this method will the form's controls update their values. If this method is not called, all
     *  the controls will preserve their default values after submission even if these values were altered prior to
     *  submission.
     *
     *  This method must be called <b>before</b> the {@link render()} method or error messages will not be
     *  available.
     *
     *  After calling this method, if there are {@link MyZebra_Form_File file} controls on the form, you might want to check
     *  for the existence of the {@link $file_upload} property to see the details of uploaded files and take actions
     *  accordingly.
     *
     *  Client-side validation is done on the "onsubmit" event of the form. See {@link client_side_validation()} for
     *  more information on client-side validation.
     *
     *  @return boolean     Returns TRUE if every rule was obeyed, FALSE if not.
     */
    function isSubmitted()
    {
        // reference to the form submission method
        global ${'_' . $this->form_properties['method']};

        $method = & ${'_' . $this->form_properties['method']};
        
        $isSubmitted=false;
        // continue only if form was submitted
        if (


            (array_key_exists($this->form_properties['identifier'],$method) ||
            isset($method[$this->form_properties['identifier']])) &&

            $method[$this->form_properties['identifier']] == $this->form_properties['name']

        ) {
            $isSubmitted=true;
        }
        
        return $isSubmitted;
    }
    
    function get_submitted_values()
    {
        // reference to the form submission method
        global ${'_' . $this->form_properties['method']};

        $method = & ${'_' . $this->form_properties['method']};

        // enable protection against CSRF attacks using the default values
        // note that this has no effect if this method was already called before
        $this->csrf();

        // we assume the form is not valid (or it was not submitted)
        $form_is_valid = false;

        // continue only if form was submitted
        if (

            $this->isSubmitted()
        ) {

            // if
            if (

                // the "honeypot" field was submitted AND
                isset($method[$this->form_properties['honeypot']]) &&

                // the "honeypot" field is empty
                $method[$this->form_properties['honeypot']] == '' &&

                // no possible CSRF attacks detected
                ($csrf_status = $this->_csrf_validate())

            ) {

                // remove the honeypot and csrf entries so that we don't polute the $_POST array
                unset($method[$this->form_properties['honeypot']]);
                unset($method[$this->form_properties['csrf_token_name']]);

                // by default, we assume that the form is valid
                $form_is_valid = true;

                // iterate through the controls
                foreach (array_keys($this->controls) as $key) {

                    // reference to control
                    $control = & $this->controls[$key];

                    // get control value(s)
                    $control->get_submitted_value();
                }
             // else if
           } elseif (

                // honeypot field was not submitted
                !isset($method[$this->form_properties['honeypot']]) ||

                // honeypot field is not empty
                $method[$this->form_properties['honeypot']] != ''

            // show the appropriate error message to the user
            ) $this->add_error('*spam*', $this->form_properties['language']['spam_detected']);

            // else, if a possible CSRF attack was detected
            // show the appropriate error message to the user
            elseif (!$csrf_status) $this->add_error('*spam*', $this->form_properties['language']['csrf_detected']);

        // here's a special error check:
        // due to a bug (?) when the POST/GET data is larger than allowed by upload_max_filesize/post_max_size the
        // $_POST/$_GET/$_FILES superglobals are empty (see http://bugs.php.net/bug.php?id=49570)
        // but still, we need to present the user with some error message...
        } elseif (empty($method) && isset($_SERVER['CONTENT_LENGTH']) && (int)$_SERVER['CONTENT_LENGTH'] > 0)

            $form_is_valid = false;

        $this->_form_is_valid=$form_is_valid;
        return $form_is_valid;
    }
    
    function checkConditionals()
    {
        // get parser
        require_once dirname(__FILE__).'/MyZebra_Parser.php';
        // localize dates
        MyZebra_DateParser::setDateLocaleStrings($this->language['days'], $this->language['months']);
        
        // add parameters for parser, these must also be used in js parser
        if (isset($this->extra_parameters['parser_info']))
            MyZebra_Parser::setParams($this->extra_parameters['parser_info']);
            
        foreach ($this->conditionals as $id=>$conditional)
        {
            //print_r(sprintf('%s is %s <br />',$id,($conditional->isDiscarded())?'DISCARDED':'NOT DISCARDED'));
            // control already discarded
            if ($conditional->isDiscarded()) continue;
            
            $data=$conditional->getConditionData();
            
            // condition is not valid, show group by default
            if (!$data['valid']) continue;
            
            $condition=$data['replaced_condition'];
            // get variable values from fields
            $vars=$data['var_field_map']['replace'];
            $fields=$data['var_field_map']['field_reference'];
            $vars_ok=true;
            $parser_vars=array();
            foreach ($vars as $key=>$vv)
            {
                // var refers to field control that not exist
                if (!isset($fields[$key]) || !isset($this->controls[$fields[$key]]))
                {
                    $vars_ok=false;
                    break;
                }
                $field=$this->controls[$fields[$key]];
                $field_values=$field->get_values_for_conditions();
                $isDate=false;
                $format='';
                if (
                    $field->attributes['type']=='checkbox' ||
                    $field->attributes['type']=='checkboxes' ||
                    $field->attributes['type']=='select'
                    )
                {
                    if (!is_array($field_values))
                        $field_values=array($field_values);
                }
                // date field
                if (isset($field->attributes['class']) && strpos($field->attributes['class'],'myzebra-date')>=0 && isset($field->attributes['format']))
                {
                    $isDate=true;
                    $format=$field->attributes['format'];
                }
                $type='string';
                if ($isDate)
                    $type='date';
                elseif (is_array($field_values))
                    $type='array';
                    
                $parser_vars[]=array(
                    'name'=>$vv,
                    'val'=>$field_values,
                    'withType'=>$type,
                    'format'=>$format
                );
                
            }
            // bypass this group, show by default
            if (!$vars_ok) continue;
            
            // evaluate condition
            try{
                //print_r($parser_vars);
                $parser=new MyZebra_Parser($condition);
                foreach ($parser_vars as $var)
                    $parser->addVar($var);
                $showGroup=(bool)$parser->evaluate();
            }catch (Exception $e)
            {
                $showGroup=false;
            }
            $data['result']=$showGroup;
            
            $this->conditionals[$id]->setConditionData($data);
            
            // discard this group and its contents from further processing
            if (!$showGroup)
            {
                $this->conditionals[$id]->discard();
               // print_r('<br />'.$id.' is Discarded<br />');
            }
            //else
              //  print_r('<br />'.$id.' is Shown<br />');
        }
        /*foreach ($this->conditionals as $id=>$conditional)
        {
            //print_r(sprintf('%s is %s <br />',$id,($conditional->isDiscarded())?'DISCARDED':'NOT DISCARDED'));
            if ($conditional->getParent()!==null)
            {
                $parent=$conditional->getParent();
                print_r(sprintf('Parent %s is %s <br />',$parent->attributes['id'],($parent->isDiscarded())?'DISCARDED':'NOT DISCARDED'));
            }
            foreach ($conditional->controls as $control)
            {
                print_r(sprintf('Child %s is %s <br />',$control->attributes['id'],($control->isDiscarded())?'DISCARDED':'NOT DISCARDED'));
            }
        }*/
    }
    
    function validate($only=false)
    {

        // reference to the form submission method
        global ${'_' . $this->form_properties['method']};

        $method = & ${'_' . $this->form_properties['method']};

        // we assume the form is not valid (or it was not submitted)
        if (!$only)
            $form_is_valid = $this->get_submitted_values();
        else
            $form_is_valid=$this->_form_is_valid;
          
        // continue only if form was submitted
        if (

            $this->isSubmitted()
        ) {

            // if
            if (

               $form_is_valid

            ) {

                // remove the honeypot and csrf entries so that we don't polute the $_POST array
                //unset($method[$this->form_properties['honeypot']]);
                //unset($method[$this->form_properties['csrf_token_name']]);

                // by default, we assume that the form is valid
                $form_is_valid = true;
                
                // remove any controls that belong to discarded conditional groups
                $this->checkConditionals();
                
                // iterate through the controls
                foreach (array_keys($this->controls) as $key) {

                    if ($this->controls[$key]->isDiscarded() || $this->controls[$key]->isContainer()) continue;
                    
                    // reference to control
                    $control = & $this->controls[$key];

                    // validate the control
                    $valid = $control->validate($only);

                    // if control is not valid, the form is not valid
                    if (!$valid) 
                    {
                        //cred_log('VALIDATE \n'.print_r($this->controls[$key],true));
                        $form_is_valid = false;
                    }

                }

                // after iterating through all the controls,
                // check if the form is still valid
                if ($form_is_valid)
                {
                    // iterate through the controls
                    foreach (array_keys($this->controls) as $key) {

                        if ($this->controls[$key]->isDiscarded() || $this->controls[$key]->isContainer()) continue;
                        
                        // reference to control
                        $control = & $this->controls[$key];

                        // do post-validation actions
                        $valid=$control->doActions();
                        
                        if (!$valid)
                        {
                            //cred_log('ACTIONS \n'.print_r($this->controls[$key],true));
                            $form_is_valid=false;
                            break;
                        }
                    }
                }
            }
        }
                
        if (!$form_is_valid)
        {
            foreach (array_keys($this->controls) as $key) 
            {
                // reset file fields if form not valid and file is uploaded
                if ($this->controls[$key]->attributes['type']=='file' && isset($this->controls[$key]->file_data) && !empty($this->controls[$key]->file_data))
                    $this->controls[$key]->reset();
            }
        }
        
        // if 
        if (

            // form is valid
            $form_is_valid ||

            // form is invalid and the from was not submitted via AJAX
            !isset($_SERVER['HTTP_X_REQUESTED_WITH'])

        // regenerate the CSRF token
        ) $this->_csrf_generate_token(true);

        // return the state of the form
        return $form_is_valid;

    }

    /**
     *  This method performs the server-side validation of a control, making sure that the value complies to the rules
     *  set for the control through the {@link MyZebra_Form_Control::set_rule() set_rule()} method.
     *
     *  @param  string  $control    Unique name that identifies the control in the form.
     *
     *  @return boolean             Returns TRUE if every rule was obeyed, FALSE if not.
     */

    /**
     *  Generates a CSRF token, unique to the current form.
     *
     *  Note that this will generate a new CSRF token only when the form is generated and not also when the form is
     *  submitted - unless the <b>$force</b> argument is set to TRUE.
     *
     *  @param  boolean $force                  (Optional) Instructs the method to forcefully generate a new CSRF token.
     *
     *                                          This parameter will be TRUE when the method is called after an unsuccessful
     *                                          CSRF token validation or after a successful form validation.
     *
     *                                          By default, this method will generate a new CSRF token *only* if the form
     *                                          is not being currently submitted (form information is not available in the $_POST
     *                                          superglobal).
     *
     *                                          Default is FALSE.
     *
     *  @return void
     *
     *  @access private
     */
    function _csrf_generate_token($force = false)
    {

        // if CSRF protection is enabled (is not boolean FALSE) and CSRF token was not already generated
        if ($this->form_properties['csrf_storage_method'] !== false) {

            // reference to the form submission method
            global ${'_' . $this->form_properties['method']};

            $method = & ${'_' . $this->form_properties['method']};

            // if
            if (

                // form was submitted and we don't need to forcefully generate a new token
                isset($method[$this->form_properties['identifier']]) && $force === false &&
                // CSRF token is stored in a session variable
                $this->form_properties['csrf_storage_method'] == 'session' &&
                // the session variable exists
                isset($_SESSION[$this->form_properties['csrf_cookie_name']]) &&
                // the session variable holds an array
                is_array($_SESSION[$this->form_properties['csrf_cookie_name']]) &&
                // the array has 2 entries
                count($_SESSION[$this->form_properties['csrf_cookie_name']]) == 2

            // use the already existing CSRF token
            ) $this->form_properties['csrf_token'] = $_SESSION[$this->form_properties['csrf_cookie_name']][0];

            // else if
            elseif (

                // form was submitted and we don't need to forcefully generate a new token
                isset($method[$this->form_properties['identifier']]) && $force === false &&
                // CSRF token is stored in a cookie
                $this->form_properties['csrf_storage_method'] == 'cookie' &&
                // the cookie exists
                isset($_COOKIE[$this->form_properties['csrf_cookie_name']])

            // use the already existing CSRF token
            ) $this->form_properties['csrf_token'] = $_COOKIE[$this->form_properties['csrf_cookie_name']];

            // else, if form was not submitted, or we force new token generation
            elseif (!isset($method[$this->form_properties['identifier']])|| $force === true) {

                // generate a random token
                $this->form_properties['csrf_token'] = md5(uniqid(rand(), true));

                // compute token expiry timestamp
                $csrf_token_expiry = $this->form_properties['csrf_token_lifetime'] == 0 ? 0 : time() + $this->form_properties['csrf_token_lifetime'];

                // if storage method is "session"
                if ($this->form_properties['csrf_storage_method'] == 'session') {

                    // if no session is started, trigger an error message
                    if (!isset($_SESSION)) _myzebra_form_show_error('You have chosen to enable protection against cross-site request forgery (CSRF) attacks and to use sessions for storing the CSRF token, but a session is not started! Start a session prior to calling the "csrf()" method', E_USER_ERROR);

                    // if sessions are on, store the CSRF token and the expiration data in session
                    $_SESSION[$this->form_properties['csrf_cookie_name']] = array($this->form_properties['csrf_token'], $csrf_token_expiry);

                // if storage method is "cookie"
                } else

                    // store the CSRF token in a cookie
                	setcookie(
                        $this->form_properties['csrf_cookie_name'],
                        $this->form_properties['csrf_token'],
                        $csrf_token_expiry,
                        $this->form_properties['csrf_cookie_config']['path'],
                        $this->form_properties['csrf_cookie_config']['domain'],
                        $this->form_properties['csrf_cookie_config']['secure'],
                        $this->form_properties['csrf_cookie_config']['httponly']
                    );

            }

        }

    }

    /**
     *  Validates CSRF token.
     *
     *  @return boolean     Returns TRUE if protection against CSRF attacks is disabled or it is enabled and the CSRF
     *                      token validates, or FALSE otherwise.
     *
     *  @access private
     */
    function _csrf_validate()
    {

        // if CSRF protection is enabled (is not boolean FALSE)
        if ($this->form_properties['csrf_storage_method'] !== false) {

            // reference to the form submission method
            global ${'_' . $this->form_properties['method']};

            $method = & ${'_' . $this->form_properties['method']};

            // if
            if (

                // the hidden field with the CSRF token was submitted
                isset($method[$this->form_properties['csrf_token_name']]) && (

                    // CSRF token is stored in a session variable
                    ($this->form_properties['csrf_storage_method'] == 'session' &&
                    // the session variable exists
                    isset($_SESSION[$this->form_properties['csrf_cookie_name']]) &&
                    // the session variable holds an array
                    is_array($_SESSION[$this->form_properties['csrf_cookie_name']]) &&
                    // the array has 2 entries
                    count($_SESSION[$this->form_properties['csrf_cookie_name']]) == 2 &&
                    // the value of the hidden field and the value in the session match
                    $method[$this->form_properties['csrf_token_name']] == $_SESSION[$this->form_properties['csrf_cookie_name']][0] &&
                    // if CSRF token doesn't expire or it does but it didn't yet
                    ($_SESSION[$this->form_properties['csrf_cookie_name']][1] == 0 || $_SESSION[$this->form_properties['csrf_cookie_name']][1] > time()))

                    ||

                    // CSRF token is stored in a cookie
                    ($this->form_properties['csrf_storage_method'] == 'cookie' &&
                    // the cookie exists
                    isset($_COOKIE[$this->form_properties['csrf_cookie_name']]) &&
                    // the value of the hidden field and the value in the cookie match
                    $method[$this->form_properties['csrf_token_name']] == $_COOKIE[$this->form_properties['csrf_cookie_name']])

                )

            // everything seems in order, then
            ) return true;

            // if we get here something was fishy...
            return false;

        }

        // if protection against CSRF attacks is not enabled, pretend nothing happened
        return true;

    }


}

/**
 *  A custom function for showing error messages in the MyZebra_Form's environment.
 *
 *  We need this so we show correct file/line number information when reporting errors as PHP's trigger_error() shows the
 *  file and the line number where the function is called and it is not what we need here (we always trigger the errors
 *  from one of the MyZebra_Form's file but the errors come from user files).
 *
 *  I didn't use a custom error handler so I don't interfere with the one you might be using.
 *
 *  @param  string  $message    The message to be shown to the user.
 *
 *  @param  mixed   $type       Severity of the error message.
 *
 *                              Can be E_USER_ERROR, E_USER_NOTICE or E_USER_WARNING.
 *
 *                              When set to E_USER_ERROR the execution of the script will be halted after the error
 *                              message is displayed.
 *
 *  @return void
 *
 *  @access private
 */
function _myzebra_form_show_error($message, $type)
{

    // if error reporting is on
    if (($type & error_reporting()) == $type) {

        // get backtrace information
        $backtraceInfo = debug_backtrace();

        // this is where the error actually occurred
        $errorInfo = array_pop(array_slice($backtraceInfo, 2, 1));

        // show error message
        echo '<br><strong>' . ($type == E_USER_WARNING ? 'Warning' : ($type == E_USER_NOTICE ? 'Notice' : 'Fatal error')) . '</strong>:  ' . $message . ' in <strong>' . basename($errorInfo['file']) . '</strong> on line <strong>' . $errorInfo['line'] .  '</strong><br>';

        // die if necessary
        if ($type == E_USER_ERROR) die();

    }

}
?>